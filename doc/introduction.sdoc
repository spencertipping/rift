Rift: Ruby In Functional Terms.
I started this project because my wife wanted a faster Ruby runtime for her birthday. Seriously. She came up to me and said "Spencer, I want you to write a faster Ruby runtime so that web
programmers don't all jump to Scala instead." Logical enough, I suppose. So I did some reading and started writing Rift.

Introduction.
Rift is a self-hosting JIT compiler written entirely in Ruby. Here's the project structure:

| 1. src/core.*         This implements a subset of Ruby called Rift-core. It's written in itself, which is important because it will later be used to interpret itself.
  2. src/asm.*          Implements processor-specific assembler backends. These are used by compilers to compile Ruby to machine code -- this happens both during JIT and to create
                        bin/rift-$os-$arch.
  3. src/compiler.*     Implements the high-level logic to transform Rift-core code into low-level constructs that the assembly layer can understand. Compilers can be specialized to include
                        other syntactic constructs.
  4. src/lib.*          Miscellaneous library functions used by other components.
  5. src/stdlib.*       An implementation of the Ruby standard library in Rift-core.

Here's how Rift is built:

| 1. MRI or YARV is used to interpret the Rift-core compiler, which is run on its own source. This yields a binary called bin/rift-$os-$arch.boot (e.g. bin/rift-linux-x64.boot for me).
  2. Because this compiled version can't have been traced, it is unoptimized. To fix this, bin/rift-linux-x64.boot is run on its own source code and produces traces and JIT segments. This
     information is used to emit a more performant version, bin/rift-linux-x64.pre.
  3. As a final integration test, bin/rift-linux-x64.pre is run exactly as bin/rift-linux-x64.boot was, producing bin/rift-linux-x64. This should be identical to bin/rift-linux-x64.pre; if
     not, then the JIT compiler isn't transparent under Ruby semantics.

Contents.
Most of the high-level stuff is contained in this doc/ directory. Here's what each file documents (listed in the recommended reading order):

| literature.sdoc
  Background reading (useful if you're new to compiler writing, as I was when I started this project). I highly recommend consulting this if something in the source code doesn't make sense;
  there's a lot of fairly esoteric functional stuff going on.

| boot-core.sdoc
  Talks about the core language that the compiler handles. This is a simplified subset of Ruby that eliminates a bunch of complexity. I also talk a bit about where the standard library picks
  up, which is further discussed in boot-stdlib.sdoc.

| compiler.sdoc
  Discusses unoptimized compilation at a high level. This includes talking about the parser, lexical scope analyzer, CPS converter, etc. After reading this and x64-compiler.sdoc, the process
  by which Rift interprets stuff (without traced optimization) should mostly make sense.

| x64-compiler.sdoc
  A fairly detailed low-level design of the initial x86-64 compiler. This particular compiler generates unoptimized code that is then traced and given to the optimizer when a hotspot is
  identified. However, the details of this compiler are very important because the structures that it uses are accessed as Ruby classes by the optimizer.

| x64-gc.sdoc
  Gory details of the garbage collector for x86-64. It's callable as a method on Rift::Kernel and runs automatically when the heap is full. This is an implementation detail more than an API
  that gets used elsewhere, so there isn't a particular reason to read it unless you're interested to see how Rift collects garbage.

| stdlib.sdoc
  Talks about the design decisions behind the standard library, and in particular where it deviates from the one implemented by MRI/YARV. For low-level implementation details such as
  performance bounds, the individual source files are your best bet. Each method contains a description of its time and space complexity in the comments.

| x64-optimizer.sdoc
  A fairly detailed low-level design of the x86-64 tracer and optimizer. Discusses the kinds of processor-specific optimizations that get performed, along with the assumptions required to
  perform them. Also goes into details about the internals of the JIT system.

Implementation biases.
As the name suggests, I decided to interpret Ruby in a different way than it's normally done. First, I'm emphasizing functional constructs and performance over object-oriented stuff. This
means that closure allocation and local variable access are really fast, full re-entrant continuations are supported and are also fast, and a lot of compiler internals are available for you to
use from the standard library.

Second, Rift isn't really Ruby. Specifically, it's a function that produces Ruby-ish interpreters and compilers. To be exact, Rift lets you change the way Ruby behaves at a much lower level
than most programmers are used to. So, for example, the 'class' and 'def' constructs were added to the base language after the fact:

normal_ruby = Rift::Compiler.new do
  block_form 'class :name', :name => Rift::Tree::Constant do
    self.const_set name, Class.new &body
  end

  block_form 'class :name < :base', :name => Rift::Tree::Constant, :base => Rift::Tree::Expression do
    self.const_set name, Class.new(base, &body)
  end

  block_form 'class << :expression', :expression => Rift::Tree::Expression do
    expression.singleton_class.class_eval &body
  end

  create_a_method = lambda do
    self.define_method method, Rift::Compiler.compile_method(formals, body)
    self
  end

  block_form 'def :method :formals',  :method => Rift::Tree::Identifier, :formals => Rift::Tree::Formals, &create_a_method
  block_form 'def :method(:formals)', :method => Rift::Tree::Identifier, :formals => Rift::Tree::Formals, &create_a_method
end

You can then replace the normal Kernel#require method (though there are less heavy-handed ways to achieve a similarly convenient API):

class Kernel
  def require file
    normal_ruby.require file
  end
end

On top of this, you can add your own operators and other syntactic forms. Please don't misuse this flexibility! You're probably best off not using it at all, but in the spirit of flexibility
that made Rails a ghetto I'm making it available as a feature if you want to use it.

  Important differences from MRI/YARV.
  Rift isn't 100% compliant as a Ruby implementation, though most of the incompatibilies aren't particularly noticeable. Here are some of the big ones:

  | 1. Rift doesn't expose a C API. You can use Rift::FFI classes to call external C libraries, but there isn't a straightforward way to call back from C or C++.
    2. Everything is a closure. Class bodies, method bodies, etc. are all lexically scoped and can refer to surrounding variables.
    3. You can now subclass Class, and the Rift standard library contains several such subclasses.
    4. No guarantees at all are made about the binary representation of objects.
    5. The class hierarchy may differ from the MRI/YARV standard, though it should be compatible (i.e. parent relationships should be preserved through transitivity).

Rift-core.
Rift-core is the core language used to bootstrap the compiler. I chose to do it this way to simplify the bootstrapping logic; Ruby itself is a complex language, whereas Rift-core is about as
simple as Smalltalk. Unlike Ruby, Rift-core's semantics are centered around continuations and method calls. Its primitive semantic elements are:

| 1. Method invocation
  2. Side-effecting sequential evaluation
  3. Closure construction via blocks

Its syntax is constructed to be valid Ruby despite being evaluated differently. Note, however, that it is a subset; not all valid Ruby is valid Rift-core. Rift-core's compiler is implemented
as an extensible library to allow addition of Ruby constructs and specialization beyond pure Ruby.
