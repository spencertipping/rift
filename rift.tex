\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}

\lstnewenvironment{resourcecode}{}{}


\title{Rift Compiler}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}

\chapter{Introduction}
  Rift is structured as a self-hosting JIT compiler. The advantage of this approach is that it's fairly straightforward to bootstrap into a native tracing JIT. The main disadvantage is a
  highly convoluted build process that involves multiple compilations. Here's how the source code is structured:

\begin{enumerate}
\item[\tt asm/]    An ELF generator and x86-64 assembler implemented in pure Ruby
\item[\tt core/]   A compiler from Rift-core (a subset of Ruby) to x86-64 assembly implemented in Rift-core
\item[\tt stdlib/] An alternative standard library implemented in Rift-core
\item[\tt jit/]    An optimizing trace compiler written using the alternative standard library
\end{enumerate}

  \noindent The build process consists of these two steps:

\begin{enumerate}
\item{YARV or MRI is used to run the Rift compiler source on itself to produce {\tt bin/rift}}
\item{{\tt bin/rift} is used on its own source to produce an optimized {\tt bin/rift}}
\end{enumerate}

\section{Internal differences from Rubinius}
    Rubinius implements a bootstrapping JIT compiler for Ruby that is designed with many of the same considerations. The main deviation is in the semantic model for Ruby. Rubinius aims for
    100\% compatibility with the existing MRI toolchain, including C API source compatibility. Possibly as a result of this decision, certain features such as {\tt call/cc} are unimplemented,
    yielding an arguably more complex interpreter.

    Rift's implementation is centered around continuation-passing style, even to the point of defining an alternative assembly-level calling convention to support it. This results in very fast
    processing of nonlocal exits, {\tt call/cc}, exceptions, etc. It may never support extensions written in C, though direct access to the assembly-level compiler should provide a viable
    alternative.

\section{Linguistic differences from Ruby 1.9}
    Rift is centered around the Rift-core language mentioned earlier. Rift-core is a generalization of Ruby that can be customized to implement a superset of Ruby 1.9. However, it can also
    implement things outside of the official Ruby standard. In particular, it supports generalizations such as user-defined operators, first-class prefix and postfix modifiers (e.g.~{\tt
    rescue}, {\tt until}), first-class declarative syntax (e.g.~{\tt class}, {\tt def}), and numerous compiler-related extensions to the standard library.

\chapter{Rift-Core}
  Rift-core is a generalized subset of Ruby that forms the basis for the Rift compiler. As described earlier, it is designed to be specialized to conform to the existing Ruby implementation,
  though it can also be customized in other ways. This chapter describes its syntax and semantics.

\lstset{caption={core/init.rb},name={core/init.rb}}\begin{rubycode}
const_set :Rift, Module.new

require 'core/lib/init'
require 'core/tree/init' \end{rubycode}

\section{Design pattern: extensible subclassing}
    Rather than have subclasses be ``parallel'' to their parents, the subclasses in Rift-core are generally stored as constants. So, for instance, if {\tt A < B}, then {\tt A}'s constant would
    be stored as {\tt B::A}. {\tt Rift::Extensible} provides a method to do this:

\lstset{caption={core/lib/init.rb},name={core/lib/init.rb}}\begin{rubycode}
require 'core/lib/extensible' \end{rubycode}

\lstset{caption={core/lib/extensible.rb},name={core/lib/extensible.rb}}\begin{rubycode}
Rift.const_set :Extensible, Module.new do
  define_method :extensible_subclass do |name, &initializer|
    child = Class.new self, &initializer
    const_set name, child
    self
  end
end \end{rubycode}

\section{Syntax elements}
    The unspecialized Rift-core parser knows how to deal with the following syntax elements:

\begin{itemize}
\item{Line comments}
\item{Strings without {\tt \#\{...\}} escapes}
\item{Unquoted symbols}
\item{64-bit signed integers}
\item{Double-precision floating point numbers}
\item{{\tt true}, {\tt false}, {\tt nil}, and {\tt self}}
\item{Class variables (e.g.~{\tt @foo})}
\item{Global variables (e.g.~{\tt \$bar})}
\item{Constants (e.g.~{\tt Foo})}
\item{Arrays of expressions}
\item{Ruby 1.8-style hashes (e.g.~{\tt \{:foo => :bar\}})}
\item{Ruby 1.9-style hashes (e.g.~{\tt \{foo:~:bar\}})}
\item{{\tt do ... end} blocks}
\item{Heredocs (this kind of hackery can't be generalized away)}
\item{Braced blocks}
\item{Destructuring block binds}
\item{Last-parameter variadic binds}
\item{Ruby infix and prefix operators (e.g.~{\tt +}, {\tt <<}, {\tt =}, {\tt ...}, {\tt ::}, etc.)}
\end{itemize}

    Notably absent from the general syntax are:

\begin{itemize}
\item{{\tt class} and {\tt def}: These are shorthands for {\tt Class.new} and {\tt define\_method}, respectively.}
\item{{\tt if}, {\tt for}, {\tt while}, etc: These are shorthands for method calls on {\tt TrueClass}, {\tt FalseClass}, and {\tt Enumerable}.}
\item{Regular expressions.}
\item{Various quoted forms such as {\tt \%x/stuff/}.}
\item{{\tt =begin} and {\tt =end}.}
\item{Short-circuit logical operators. These are defined later because they impact the evaluation semantics.}
\end{itemize}

    The parser returns an instance of {\tt Rift::Tree} that represents the original source code losslessly. Any given parser can be specialized to return new user-defined subclasses of {\tt
    Rift::Tree}, each with their own compilation semantics.

\lstset{caption={core/tree/init.rb},name={core/tree/init.rb}}\begin{rubycode}
Rift.const_set :Tree, Class.new Struct.new(:operation, :children, :source) do
  include Enumerable
  extend  Extensible

  define_method :each do |&block|
    block.call self
    @children.each &block
    self
  end
end \end{rubycode}

\chapter{Low-Level Implementation}
  Most of Ruby is simple; the complexity arises from the presence of continuations, which are so useful that they should be both available and as performant as is reasonable. However, as many
  compiler writers know, implementing reentrant continuations efficiently in a lexically-scoped language is something of a challenge. Some of the challenge is alleviated by using CPS
  conversion, but this creates many closure variables and long-scope accesses.

\chapter{x86-64 Assembler}
  Rift-core will end up being implemented in x86-64 assembly, though thankfully this process is automated. This set of assembler classes provides the facility to generate and link low-level
  code using the x86-64 instruction set. This is then either wrapped in an ELF container (useful for generating self-contained executables) or referenced as the implementation of a {\tt
  Method}. For simplicity's sake I've separated the ELF wrapper from the assembler modules, even though they share a source directory.

\end{document}
